# Schema and code generation
Provided in this directory is a python script named `compile.py` which compiles the .h (C++ header) files into their corresponding .fpp (fprime), .proto (ProtoBuffers version 2 and 3) and .msg (ROS2) files. 
Configuring the script options is done by editing the json input file(s), an example of which for the spring project is provided (`spring_defs.json`).

## json input file objects
`type_dict` - a dictionary that maps the integral types (`typedef`'ed or not) from the input headers (e.g. `float`) to their corresponding types in the schema files (e.g `F32`). **All integral types used in the headers must be mapped**. The spring example only uses the `float` type, but we added a few more examples for your convenience.

Note: the mapping for `unsigned int` for ProtoBuff is `fixed32` by default, which always uses 4 bytes. Use `uint32` for varible length (number of bytes depends on the value).

`output_dict` - a dictionary that maps a schema format to a boolean value which determines if that format will be generated in the output. A format mapped to false will be skipped. In addition, the same applies for the autogenerated translator functions (currently only FPrime-ProtoBuf).

`header_files` - a list of header files to be parsed (i.e. `io_structs.hpp` in the spring example).

`top_structs` - a list of the top level structs which are defined in `header_files`. **Notice: the header files  containing any definition of a struct or enum that is (directly or indirectly) used by `top_structs` must be listed in `header_files`**.

`header_dir` - absolute path to the directory with the input header files.

`base_output_dir` - absolute path to the directory where directories for each output format requested (via `output_dict`) will be created, inside which the out files will be written.

`base_out_name` - the base name of the output files. For each format, a file named `<base_out_name>.<format>` will be generated.

---

`schemas` - a dictionary that holds dictionaries that define special definitions needed for each of the formats. Details bellow:

`proto[package]` - the package to be defined in the proto file.

`fpp[module]` - the module to be defined in the fpp file.

`msg[base_dir]` - the base msg dir (the prefix for the struct field types) for the ROS2 schema.

`msg[enum_type]` - the underlying enum type for ROS2 messages.

---

`translators` - a dictionary that holds dictionaries that define special definitions needed for each of the translator functions. Details bellow:

`proto2fpp[proto_from]` - the name of the input argument for the `proto2fpp` translator function.

`proto2fpp[fpp_to]`- the name of the output argument for the `proto2fpp` translator function.

`fpp2proto[fpp_from]` - the name of the input argument for the `fpp2proto` translator function.

`fpp2proto[proto_to]` - the name of the output argument for the `fpp2proto` translator function.

---

The following 3 objects should rarely be changed, if ever:

`struct_decl` - a boilerplate for struct declarations as they appear in the input header files.

`enum_decl` - a boilerplate for enum declarations as they appear in the input header files.

`decl_end` - a boilerplate for the end of struct or enum declarations as they appear in the input header files.


## Usage

To generate the schema files and translators:
- for the spring example:   
`python3 compile.py spring_defs.json`

To generate ProtoBuff code from the proto files generated in the previous step:
- for the spring example:   
`protoc -I=schemas/spring/proto3 --cpp_out=./schemas/spring/proto3 spring.proto`

### ProtoBuffers pitfalls:
1. Make sure enum names are globaly unique (e.g. by adding a prefix unique to the enum), since all enums will be under the package specified.
2. Field names are not case sensitive, meaning you can't have two fields in the same struct whose names differ only in letter case (e.g. field and FIELD).

## Limitations
The `compile.py` script, contrary to what its name may suggest, does not have the parsing abilities of a fully fledged C++ compiler. It uses a bunch of heuristics and assumptions, which cover most cases. 

Specifically, it supports the following:
- structs
- nested structs
- integral types (`typedef`'ed or not)
- enums
- arrays of integral types

It does **not** support *at least* the following:
- arrays of structs
- arrays of enums
- multi-line comments (/**/) inside a struct or enum definition.